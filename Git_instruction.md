# Работа с Git.
![Git 111](Git-111.gif)
![Git 0101](Git-0101.jpg)
![Git 1_IHqZCiNdfRR8D61uL-QTfA](Git-1_IHqZCiNdfRR8D61uL-QTfA.png)
![Git git.0](Git-git.0-1024x683.jpg)
![Git c5907400](Git-c5907400-9f96-11e9-9297-099cecb075ca.png)

**Git** — это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах (чаще всего речь идет об исходном коде программ, но вы можете использовать его для любых файлов на ваш вкус). С его помощью вы можете откатиться на более старую версию вашего проекта, сравнивать, анализировать, сливать изменения и многое другое. Этот процесс называется контролем версий. Существуют различные системы для контроля версий. Вы, возможно, о них слышали: `SVN, Mercurial, Perforce, CVS, Bitkeeper` и другие.

**Git** является распределенным, то есть не зависит от одного центрального сервера, на котором хранятся файлы. Вместо этого он работает полностью локально, сохраняя данные в папках на жестком диске, которые называются репозиторием. Тем не менее, вы можете хранить копию репозитория онлайн, это сильно облегчает работу над одним проектом для нескольких людей. Для этого используются сайты вроде `github и bitbucket`.

## 1. Проверка наличия установленного Git

Установить git на свою машину очень просто:

**Linux** — нужно просто открыть терминал и установить приложение при помощи пакетного менеджера вашего дистрибутива. Для `Ubuntu` команда будет выглядеть следующим образом:
```
sudo apt-get install git
```
**Windows** — мы рекомендуем `git for windows`, так как он содержит и клиент с графическим интерфейсом, и эмулятор `bash`.
**OS X** — проще всего воспользоваться `homebrew`. После его установки запустите в терминале:
```
brew install git
```
Если вы новичок, клиент с графическим интерфейсом(например **GitHub Desktop и Sourcetree**) будет полезен, но, тем не менее, знать команды очень важно.

В терминале выполнить команду `git version`
Если Git установлен, появиться сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## 2. Установка Git
Загружаем последнюю версию Git c сайта https://git-scm.com/downlods 

## 3. Настройка Git
При первом использовании Git необходимо представиться. Для этого нужно ввести в терминале две команды:
```
git config --global user.name "Ваше имя"
git config --global user.email "lol@mail.ru"
```

## 4. Создание нового репозитория.
Чтобы создать новый репозиторий, нам нужно открыть терминал, зайти в папку нашего проекта и выполнить команду **init**. Это включит приложение в этой конкретной папке и создаст скрытую директорию .**git**, где будет храниться история репозитория и настройки.
Создайте на рабочем столе папку под названием **git_exercise**. Для этого в окне терминала введите:
```
mkdir Desktop/git_exercise/
cd Desktop/git_exercise/
git init
```
Командная строка должна вернуть что-то вроде:
```
Initialized empty Git repository in /home/user/Desktop/git_exercise/.git/
```
## 5. Определение состояния
**status** — это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запуск **git status** на нашем свежесозданном репозитории должен выдать:
```
git status
On branch master
Initial commit
Untracked files:
(use "git add ..." to include in what will be committed)
hello.txt
```

## 6. Подготовка файлов.
В **git** есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой **add** и, наконец, коммитим все нужное в репозиторий (создаем слепок нужного нам состояния) командой **commit**.
В нашем случае у нас только один файл, так что добавим его:
```
git add hello.txt
```
Если нам нужно добавить все, что находится в директории, мы можем использовать **git add -A**.
Проверим статус снова, на этот раз мы должны получить другой ответ:
**git status
On branch master
Initial commit
Changes to be committed:
(use "git rm --cached ..." to unstage)
new file: hello.txt**

## 7. Коммит фиксация изменений
Коммит представляет собой состояние репозитория в определенный момент времени. Это похоже на снапшот, к которому мы можем вернуться и увидеть состояние объектов на определенный момент времени.
Чтобы зафиксировать изменения, нам нужно хотя бы одно изменение в области подготовки (мы только что создали его при помощи **git add**), после которого мы может коммитить:
```
git commit -m "Initial commit."
```
Эта команда создаст новый коммит со всеми изменениями из области подготовки (добавление файла **hello.txt**). Ключ -m и сообщение «**Initial commit**.» — это созданное пользователем описание всех изменений, включенных в коммит. Считается хорошей практикой делать коммиты часто и всегда писать содержательные комментарии.

## 8. Подключение к удаленному репозиторию.

Чтобы загрузить что-нибудь в удаленный репозиторий, сначала нужно к нему подключиться. В нашем руководстве мы будем использовать адрес https://github.com/tutorialzine/awesome-project, но вам посоветуем попробовать создать свой репозиторий в **GitHub, BitBucket** или любом другом сервисе. Регистрация и установка может занять время, но все подобные сервисы предоставляют хорошую документацию.
Чтобы связать наш локальный репозиторий с репозиторием на **GitHub**, выполним следующую команду в терминале. Обратите внимание, что нужно обязательно изменить URI репозитория на свой.
```
# This is only an example. Replace the URI with your own repository address.
$ git remote add origin https://github.com/tutorialzine/awesome-project.git
```
Проект может иметь несколько удаленных репозиториев одновременно. Чтобы их различать, мы дадим им разные имена. Обычно главный репозиторий называется origin.

## 9. Отправка изменений на сервер.

Сейчас самое время переслать наш локальный коммит на сервер. Этот процесс происходит каждый раз, когда мы хотим обновить данные в удаленном репозитории.
Команда, предназначенная для этого - push. Она принимает два параметра: имя удаленного репозитория (мы назвали наш origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев).
```
$ git push origin master
Counting objects: 3, done.
Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://github.com/tutorialzine/awesome-project.git
* [new branch] master -> master
```
В зависимости от сервиса, который вы используете, вам может потребоваться аутентифицироваться, чтобы изменения отправились. Если все сделано правильно, то когда вы посмотрите в удаленный репозиторий при помощи браузера, вы увидите файл **hello.txt**

## 10. Клонирование репозитория.

Сейчас другие пользователи **GitHub** могут просматривать ваш репозиторий. Они могут скачать из него данные и получить полностью работоспособную копию вашего проекта при помощи команды *clone*.
```
$ git clone https://github.com/tutorialzine/awesome-project.git
```
Новый локальный репозиторий создается автоматически с **GitHub** в качестве удаленного репозитория.

## 11. Запрос изменений с сервера

Если вы сделали изменения в вашем удаленном репозитории, другие пользователи могут скачать изменения при помощи команды **pull**.
```
$ git pull origin master
From https://github.com/tutorialzine/awesome-project
* branch master -> FETCH_HEAD
Already up-to-date.
```
Так как новых коммитов с тех пор, как мы склонировали себе проект, не было, никаких изменений доступных для скачивания нет.

## 12. Ветвление. Создание новой ветки

Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют **веткой**. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:
- **Если была изменина одна и та же часть файла в обеих ветках, то может возникнуть конфликт, которыйпотребует участия пользователя.**
- **Уже рабочая, стабильная версия кода сохраняется.**
- **Различные новые функции могут разрабатываться параллельно разными программистами.**
- **Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.**
- **В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.**

Основная ветка в каждом репозитории называется `master`. Чтобы создать еще одну ветку, используем команду **branch <name>**
```
git branch amazing_new_feature
```
Это создаст новую ветку, точную копию ветки `master.`

## 13. Переключение между ветками.

Сейчас, если мы запустим **branch**, мы увидим две доступные опции:
```
git branch
amazing_new_feature
* master
```
**master** — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей **новой потрясающей фичей**, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой **checkout**, она принимает один параметр — имя ветки, на которую необходимо переключиться.
```
git checkout amazing_new_feature
```

## 14. Слияние веток
Наша “потрясающая новая фича” будет еще одним текстовым файлом под названием *feature.txt.* Мы создадим его, добавим и закоммитим:
```
git add feature.txt
git commit -m "New feature complete.”
```
Изменения завершены, теперь мы можем переключиться обратно на ветку **master.**
```
git checkout master
```
Теперь ветка **master** актуальна. Ветка **amazing_new_feature** больше не нужна, и ее можно удалить.
```
git branch -d awesome_new_feature
```

## 15. Отслеживание изменений, сделанных в коммитах.
У каждого коммита есть свой уникальный идентификатор в виде строки цифр и букв. Чтобы просмотреть список всех коммитов и их идентификаторов, можно использовать команду **log**:
```
git log
commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7
Author: Tutorialzine
Date: Mon May 30 17:15:28 2016 +0300
New feature complete
commit b10cc1238e355c02a044ef9f9860811ff605c9b4
Author: Tutorialzine
Date: Mon May 30 16:30:04 2016 +0300
Added content to hello.txt
commit 09bd8cc171d7084e78e4d118a2346b7487dca059
Author: Tutorialzine
Date: Sat May 28 17:52:14 2016 +0300
Initial commit
```
Чтобы увидеть разницу между двумя коммитами, используется команда **diff** (с указанием промежутка между коммитами):
```
 git diff 09bd8cc..ba25c0ff
diff --git a/feature.txt b/feature.txt
new file mode 100644
index 0000000..e69de29
diff --git a/hello.txt b/hello.txt
index e69de29..b546a21 100644
--- a/hello.txt
+++ b/hello.txt
@@ -0,0 +1 @@
+Nice weather today, isn't it?
```

## 16.  Возвращение файла к предыдущему состоянию.

Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Это делается уже знакомой нам командой **checkout**, которую мы ранее использовали для переключения между ветками. Но она также может быть использована для переключения между коммитами (это довольно распространенная ситуация для Гита - использование одной команды для различных, на первый взгляд, слабо связанных задач).
В следующем примере мы возьмем файл `hello.txt` и откатим все изменения, совершенные над ним к первому коммиту. Чтобы сделать это, мы подставим в команду идентификатор нужного коммита, а также путь до файла:
```
git checkout 09bd8cc1 hello.txt
```
## 17.  Исправление коммита. 

Если вы опечатались в комментарии или забыли добавить файл и заметили это сразу после того, как закоммитили изменения, вы легко можете это поправить при помощи commit —amend. Эта команда добавит все из последнего коммита в область подготовленных файлов и попытается сделать новый коммит. Это дает вам возможность поправить комментарий или добавить недостающие файлы в область подготовленных файлов.
Для более сложных исправлений, например, не в последнем коммите или если вы успели отправить изменения на сервер, нужно использовать revert. Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным идентификатором.
Самый последний коммит может быть доступен по алиасу **HEAD**:
```
git revert HEAD
```
Для остальных будем использовать идентификаторы:
```
git revert b10cc123
```
При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь git не может найти строчки, состояние которых нужно откатить, так как они больше не существуют.

## 18. Разрешение конфликтов при слиянии

Помимо сценария, описанного в предыдущем пункте, конфликты регулярно возникают при слиянии ветвей или при отправке чужого кода. Иногда конфликты исправляются автоматически, но обычно с этим приходится разбираться вручную — решать, какой код остается, а какой нужно удалить.
Давайте посмотрим на примеры, где мы попытаемся слить две ветки под названием john_branch и tim_branch. И Тим, и Джон правят один и тот же файл: функцию, которая отображает элементы массива.
Джон использует цикл:
```
// Use a for loop to console.log contents.
for(var i=0; i<arr.length; i++) {
console.log(arr[i]);
}
```
Тим предпочитает forEach:
```
// Use forEach to console.log contents.
arr.forEach(function(item) {
console.log(item);
});
```
Они оба коммитят свой код в соответствующую ветку. Теперь, если они попытаются слить две ветки, они получат сообщение об ошибке:
```
 git merge tim_branch
Auto-merging print_array.js
CONFLICT (content): Merge conflict in print_array.js
Automatic merge failed; fix conflicts and then commit the result.
```
Система не смогла разрешить конфликт автоматически, значит, это придется сделать разработчикам. Приложение отметило строки, содержащие конфликт:
[spoiler title='Вывод']
```
<<<<<<< HEAD // Use a for loop to console.log contents. for(var i=0; i<arr.length; i++) { console.log(arr[i]); } ======= // Use forEach to console.log contents. arr.forEach(function(item) { console.log(item); }); >>>>>>> Tim's commit.
```
[/spoiler]
Над разделителем ======= мы видим последний (HEAD) коммит, а под ним - конфликтующий. Таким образом, мы можем увидеть, чем они отличаются и решать, какая версия лучше. Или вовсе написать новую. В этой ситуации мы так и поступим, перепишем все, удалив разделители, и дадим git понять, что закончили.
```
// Not using for loop or forEach.
// Use Array.toString() to console.log contents.
console.log(arr.toString());
```
Когда все готово, нужно закоммитить изменения, чтобы закончить процесс:
```
git add -A git commit -m "Array printing conflict resolved."
```
Как вы можете заметить, процесс довольно утомительный и может быть очень сложным в больших проектах. Многие разработчики предпочитают использовать для разрешения конфликтов клиенты с графическим интерфейсом. (Для запуска нужно набрать **git mergetool**).

## 19. Работа с удаленными репозиториями.

Для того, чтобы внести вклад в какой-либо **Git-проект**, вам необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим некоторые из этих навыков.

Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду `git remote`. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум `origin` — имя по умолчанию, которое **Git** даёт серверу, с которого производилось клонирование:
```
 git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'..
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
 cd ticgit
 git remote
origin
```
Вы можете также указать ключ `-v`, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:
```
git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
```
Если у вас больше одного удалённого репозитория, команда выведет их все. Например, для репозитория с несколькими настроенными удалёнными репозиториями в случае совместной работы нескольких пользователей, вывод команды может выглядеть примерно так:
```
 cd grit
 git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)
```
Это означает, что мы можем легко получить изменения от любого из этих пользователей. Возможно, что некоторые из репозиториев доступны для записи и в них можно отправлять свои изменения, хотя вывод команды не даёт никакой информации о правах доступа.

 Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду git remote add `<shortname> <url>`:
 ```
 git remote
origin
 git remote add pb https://github.com/paulboone/ticgit
 git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)
```
Теперь вместо указания полного пути вы можете использовать `pb`. Например, если вы хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить команду `git fetch pb`:
```
git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
 * [new branch]      master     -> pb/master
 * [new branch]      ticgit     -> pb/ticgit
 ```
 Ветка **master** из репозитория Пола сейчас доступна вам под именем `pb/master`. Вы можете слить её с одной из ваших веток или переключить на неё локальную ветку, чтобы просмотреть содержимое ветки Пола. 

 **Получение изменений из удалённого репозитория — Fetch и Pull**
Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить:
```
git fetch [remote-name]
```
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем `«origin»`. Таким образом, `git fetch origin` извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью `fetch`). Важно отметить, что команда `git fetch` забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Если ветка настроена на отслеживание удалённой ветки, то вы можете использовать команду `git pull` чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда `git clone` автоматически настраивает вашу локальную ветку **master** на отслеживание удалённой ветки **master** на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение `git pull`, как правило, извлекает `(fetch)` данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить `(merge)` их с кодом, над которым вы в данный момент работаете.

**Отправка изменений в удаленный репозиторий (Push)**

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: `git push <remote-name> <branch-name>`. Чтобы отправить вашу ветку **master** на сервер `origin` (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:
```
git push origin master
```
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду `push`, а после него выполнить команду `push` попытаетесь вы, то ваш `push` точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить `push`.

**Просмотр удаленного репозитория**.

Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду `git remote show <remote>`. Выполнив эту команду с некоторым именем, например, `origin`, вы получите следующий результат:
```
git remote show origin
* remote origin
  Fetch URL: https://github.com/schacon/ticgit
  Push  URL: https://github.com/schacon/ticgit
  HEAD branch: master
  Remote branches:
    master                               tracked
    dev-branch                           tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)
    ```

   Она выдаёт `URL` удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке master, выполните `git pull`, ветка **master** с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.

Это был пример для простой ситуации и вы наверняка встречались с чем-то подобным. Однако, если вы используете `Git` более интенсивно, вы можете увидеть гораздо большее количество информации от `git remote show`:
```
git remote show origin
* remote origin
  URL: https://github.com/my-org/complex-project
  Fetch URL: https://github.com/my-org/complex-project
  Push  URL: https://github.com/my-org/complex-project
  HEAD branch: master
  Remote branches:
    master                           tracked
    dev-branch                       tracked
    markdown-strip                   tracked
    issue-43                         new (next fetch will store in remotes/origin)
    issue-45                         new (next fetch will store in remotes/origin)
    refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)
  Local branches configured for 'git pull':
    dev-branch merges with remote dev-branch
    master     merges with remote master
  Local refs configured for 'git push':
    dev-branch                     pushes to dev-branch                     (up to date)
    markdown-strip                 pushes to markdown-strip                 (up to date)
    master                         pushes to master                         (up to date)
```
Данная команда показывает какая именно локальная ветка будет отправлена на удалённый сервер по умолчанию при выполнении `git push`. Она также показывает, каких веток с удалённого сервера у вас ещё нет, какие ветки всё ещё есть у вас, но уже удалены на сервере, и для нескольких веток показано, какие удалённые ветки будут в них влиты при выполнении `git pull`.

**Удаление и переименование удалённых репозиториев**

Для переименования удалённого репозитория можно выполнить `git remote rename. Например`, если вы хотите переименовать `pb в paul`, вы можете это сделать при помощи `git remote rename`:
```
git remote rename pb paul
 git remote
origin
paul
```
Стоит упомянуть, что это также изменит имена удалённых веток в вашем репозитории. То, к чему вы обращались как `pb/master`, теперь стало `paul/master`.

Если по какой-то причине вы хотите удалить удаленный репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать `git remote rm`:
```
git remote remove paul   git remote
origin
```
При удалении ссылки на удалённый репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, так же будут удалены.

## 20. Настройка .gitignore.

В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. Мы можем удостовериться, что они случайно не попадут в git add -A при помощи файла **.gitignore**
 - Создайте вручную файл под названием **.gitignore** и сохраните его в директорию проекта.
 - Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.
 - Файл **.gitignore** должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.

 Вот хорошие примеры файлов, которые нужно игнорировать:
```
 - Логи
 - Артефакты систем сборки
 - Папки node_modules в проектах node.js
 - Папки, созданные IDE, например, Netbeans или IntelliJ
 - Разнообразные заметки разработчика.
 ```
 Файл **.gitignore**, исключающий все перечисленное выше, будет выглядеть так:
 ```
 *.log
build/
node_modules/
.idea/
my_notes.txt
```
Символ слэша в конце некоторых линий означает директорию (и тот факт, что мы рекурсивно игнорируем все ее содержимое). Звездочка, как обычно, означает шаблон.

## 21. Заключение.

Вот и все! Наше руководство окончено. 
**Git** довольно сложен, и в нем есть еще много функций и трюков.
 **P.S. Для облегчения обучения, оставлю вам ссылку на бесплатный тренажер по Git.**
`https://learngitbranching.js.org/`


